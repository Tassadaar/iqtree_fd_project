import glob
import math
import os
import sys
import argparse
import subprocess
import concurrent.futures
import itertools
import re
import time

from ete3 import Tree, TreeStyle, TreeNode
from Bio import AlignIO


def main(args):
    try:
        master_tree = Tree(args.tree)
        alignment_address = args.alignment
        alignment = validate_alignment(master_tree, alignment_address)
        defined_groups = validate_def_file(master_tree, args.definition)
        models = args.model.split("+")  # syntax: Rate Matrix+Mixture Model+Rate Heterogeneity
        nexus_address = args.nexus
        all_cores = int(args.cores)  # total number of cores allocated to this program
        memory = int(args.memory)
        a_tree, b_tree = get_ref_subtrees(master_tree, defined_groups)

        # write subtrees into newick files
        a_tree.write(format=1, outfile="test_a.newick")
        b_tree.write(format=1, outfile="test_b.newick")

        # split alignment into two sub-alignments
        a_alignment, b_alignment = write_alignment_partitions(alignment, a_tree, b_tree)
        AlignIO.write(a_alignment, "test_a.aln", "fasta")
        AlignIO.write(b_alignment, "test_b.aln", "fasta")

        iqtree_commands = []

        # first iqtree execution
        if all_cores > 2:
            cores = all_cores // 2
        else:
            cores = 1

        for subset in ["test_a", "test_b"]:

            iqtree_command = [
                "iqtree2",
                # NOTE: this is currently slightly wasteful, if the number of cores is odd then the second command
                #   should receive an additional core
                "-nt", str(cores),
                "-s", f"{subset}.aln",
                "-te", f"{subset}.newick",
                "-mwopt",
                "-prec", "10",
                "--prefix", subset,
                "--quiet",
                "-m", "+".join(models)
            ]

            if nexus_address:
                iqtree_command = iqtree_command + ["--mdef", nexus_address]

            iqtree_commands.append(iqtree_command)

        with concurrent.futures.ThreadPoolExecutor(max_workers=2) as executor:
            futures = []

            for command in iqtree_commands:
                print(f"Running iqtree funDi for Tree {command[4][5]} out of 2")
                futures.append(executor.submit(subprocess.run, command, stderr=subprocess.DEVNULL))

            print()  # divider

            for future in concurrent.futures.as_completed(futures):
                result = future.result()
                print(f"Completed running Tree {result.args[4][5]}.")

        # check if the new trees generated by iqtree have the same topology
        a_tree = conform_iqtree_tree("test_a.treefile", a_tree.get_children()[0].get_leaf_names())
        b_tree = conform_iqtree_tree("test_b.treefile", b_tree.get_children()[0].get_leaf_names())

        trees = []
        denominator = int(1 / float(args.increment))
        proportions = [x / denominator for x in range(1, denominator)]
        a_branch = a_tree.get_children()[0].dist + a_tree.get_children()[1].dist
        b_branch = b_tree.get_children()[0].dist + b_tree.get_children()[1].dist

        print(f"\nbranch a: {a_branch}, branch b: {b_branch}\n")

        # get alpha and beta from a cartesian product of proportions
        for alpha, beta in itertools.product(proportions, repeat=2):

            # set new branch lengths for a
            a_tree.get_children()[0].dist = a_branch * alpha
            a_tree.get_children()[1].dist = a_branch * (1 - alpha)

            # set new branch lengths for b
            b_tree.get_children()[0].dist = b_branch * beta
            b_tree.get_children()[1].dist = b_branch * (1 - beta)

            # reconstruct master tree
            new_master_tree = TreeNode(dist=0.1)
            new_master_tree.add_child(a_tree.copy("deepcopy"))
            new_master_tree.add_child(b_tree.copy("deepcopy"))

            assert new_master_tree.robinson_foulds(master_tree)[0] == 0, "The new master tree is not the same!"

            trees.append(new_master_tree)

        # print number of trees generated
        print(f"{len(trees)} tree were generated\n")

        a_weight, b_weight = calculate_weights(a_tree, b_tree)

        avg_alpha = calculate_weighted_average_alpha(
            "test_a.iqtree", "test_b.iqtree", a_weight, b_weight
        )

        avg_mixture_weights = calculate_weighted_average_mixture_weights(
            "test_a.iqtree", "test_b.iqtree", a_weight, b_weight
        )

        # if args.nexus is not provided on the command line...
        if not nexus_address:
            # ... generate nexus file that is called 'test_nex.nex':
            nexus_address, models[1] = create_custom_nexus_file(
                avg_mixture_weights, "data/modelmixtureCAT.nex", models[1], f"CAT-{models[1]}"
            )
        # else, if it is provided on command line,
        else:
            nexus_address, models[1] = create_custom_nexus_file(
                avg_mixture_weights, nexus_address, models[1], "begin models;"
            )

        # second iqtree execution
        run_iqtrees(trees, alignment_address, avg_alpha, "+".join(models),
                    nexus_address, all_cores, memory, a_tree.get_leaf_names())

        # To get the number of trees generated, we take number of proportions to the power of 2
        generate_summary(len(trees), "+".join(models), args.increment, defined_groups, args.keep)

    except NameError as e:
        print(f"Panda-monium! {e}")

    except ValueError as e:
        print(f"Fatal: {e} Check if inputs are valid!")

    except FileNotFoundError as e:
        print(f"File not found! {e}")

    # finally:
    #     print("\nSystem exiting...")
    #     sys.exit()


def validate_alignment(tree, alignment_file):
    """
    Does the alignment have the exact same set of taxa
    as the tree?
    """
    # parsing fasta file
    alignment = AlignIO.read(alignment_file, "fasta")
    seq_ids = set(record.id for record in alignment)
    seen_taxa = set()

    for taxon in tree.get_leaf_names():

        if taxon not in seq_ids:
            raise ValueError(f"Tree taxon {taxon} does not exist in the alignment file")

        if taxon in seen_taxa:
            raise ValueError(f"Tree taxon {taxon} is duplicated in the alignment file")

        seen_taxa.add(taxon)

    return alignment


def validate_def_file(tree, def_file):
    # store definition file in memory
    # as a list of two sets of taxa
    # this ensures uniqueness, assuming that order does not matter with def files
    with open(def_file, "r") as file:
        taxa_groups = []

        for line in file:
            # clean line by removing whitespace, comma or newline characters
            clean_line = line.rstrip(" ,\n")

            # ignore empty sets
            if clean_line == "":
                continue

            # parse clean line delimited by comma or whitespace
            taxon_group = set(re.split(r"[,\s]+", clean_line))
            taxa_groups.append(taxon_group)

    # check 1: definition file must not be blank
    if not taxa_groups:
        raise ValueError(f"Definition file is blank!")

    if len(taxa_groups) > 2:
        raise ValueError(f"Definition file contains more than 2 taxa groups!")

    leaves = set(tree.get_leaf_names())  # assuming leaves are correct as reference

    # auto-complete the list if only one group of taxa is provided
    if len(taxa_groups) == 1:
        taxa_groups.append(leaves - taxa_groups[0])

    # check 2: the two groups of taxa must be non-overlapping, i.e. is there a taxon in both groups?
    if taxa_groups[0] & taxa_groups[1]:
        raise ValueError(f"Defined groups have overlapping items: {taxa_groups[0] & taxa_groups[1]}.")

    # check 3: leaves in the tree must all be in the definition file
    all_taxa = taxa_groups[0] | taxa_groups[1]
    unique_leaves = leaves - all_taxa

    if unique_leaves:
        raise ValueError(f"Some tree leaves do not exist in the definition file: {unique_leaves}.")

    # check 4: are there any taxa in the definition file that do not exist in the tree file?
    unique_taxa = all_taxa - leaves

    if unique_taxa:
        raise ValueError(f"Some taxa do not exist in the tree: {unique_taxa}.")

    return taxa_groups


def get_ref_subtrees(master_tree, leaf_groups):
    # this is good practice, but it currently breaks the code
    # master_tree_copy = master_tree.copy("deepcopy")

    # we declare these as None, so that if
    # in the code below they are not replaced with actual objects,
    # we can catch the error later
    a_tree = None
    b_tree = None

    # probe for non-root subtree
    for leaf_group in leaf_groups:
        common_ancestor = master_tree.get_common_ancestor(*leaf_group)

        if not common_ancestor.is_root():
            master_tree.set_outgroup(common_ancestor)
            a_tree, b_tree = master_tree.get_children()

    return a_tree, b_tree


def write_alignment_partitions(alignment, a_tree, b_tree):
    a_leaves = a_tree.get_leaf_names()
    b_leaves = b_tree.get_leaf_names()
    a_alignment = AlignIO.MultipleSeqAlignment([])
    b_alignment = AlignIO.MultipleSeqAlignment([])

    for record in alignment:

        if record.id in a_leaves:
            a_alignment.append(record)

        if record.id in b_leaves:
            b_alignment.append(record)

    return a_alignment, b_alignment


def conform_iqtree_tree(iqtree_treefile, ref_outgroup_leaves):
    # extracting subtree
    iqtree_tree = Tree(iqtree_treefile)

    # if outgroup is a single taxon
    if len(ref_outgroup_leaves) == 1:
        iqtree_tree.set_outgroup(ref_outgroup_leaves[0])

        return iqtree_tree

    # if outgroup is multiple taxa
    outgroup_lca = iqtree_tree.get_common_ancestor(*ref_outgroup_leaves)

    # if the lca of the ref tree outgroup taxa is
    # the root of the new iqtree tree, 
    # the ref outgroup taxa are not monophyletic
    if outgroup_lca.is_root():

        for leaf in iqtree_tree.get_leaf_names():

            # we do an initial reroot here,
            # to ensure that the ref outgroup taxa are monophyletic
            if leaf not in ref_outgroup_leaves:
                iqtree_tree.set_outgroup(leaf)
                break

    # now that they are monophyletic,
    # we can reroot with the reference outgroup taxa
    new_outgroup_lca = iqtree_tree.get_common_ancestor(*ref_outgroup_leaves)
    iqtree_tree.set_outgroup(new_outgroup_lca)

    return iqtree_tree


def calculate_weights(a_tree, b_tree):
    a_taxa_count = len(a_tree.get_leaf_names())
    b_taxa_count = len(b_tree.get_leaf_names())
    total_taxa_count = a_taxa_count + b_taxa_count

    return a_taxa_count / total_taxa_count, b_taxa_count / total_taxa_count


def calculate_weighted_average_mixture_weights(a_iqtree_file, b_iqtree_file, a_weight, b_weight):

    # get weights from iqtree log file, returns empty set if not found
    def get_mixture_weights(iqtree_file):
        mixture_weights = {}

        if not os.path.isfile(iqtree_file):
            raise FileNotFoundError(f"'{iqtree_file}' does not exist!")

        with open(iqtree_file, "r") as file:

            for line in file:

                # NOTE: this will fail if the model provided does not exist
                if "No  Component      Rate    Weight   Parameters" in line:
                    next_line = next(file)

                    while next_line != "\n":
                        words = next_line.split()
                        mixture_weights[words[0]] = float(words[3])
                        next_line = next(file)

                    break

        return mixture_weights

    a_mixture_weights = get_mixture_weights(a_iqtree_file)
    b_mixture_weights = get_mixture_weights(b_iqtree_file)

    # usefulness of these safety nets questionable,
    # but doesn't hurt
    if not a_mixture_weights:
        raise ValueError(f"Cannot extract mixture weights, check if '{a_iqtree_file}' is formatted correctly!")

    if not b_mixture_weights:
        raise ValueError(f"Cannot extract mixture weights, check if '{a_iqtree_file}' is formatted correctly!")

    # mixture_weight = weight of the mixture model class
    # weight = weight used to calculate the weighted average
    avg_mixture_weights = {}

    # a_mixture_weights and b_mixture_weights have the same keys
    for key, a_mixture_weight in a_mixture_weights.items():
        weighted_avg_weight = a_mixture_weight * a_weight + b_mixture_weights[key] * b_weight
        avg_mixture_weights[key] = weighted_avg_weight

    return avg_mixture_weights


def calculate_weighted_average_alpha(a_iqtree_file, b_iqtree_file, a_weight, b_weight):

    # get alpha from iqtree log file, returns None if not found
    def get_alpha(iqtree_file):
        alpha = None

        if not os.path.isfile(iqtree_file):
            raise FileNotFoundError(f"'{iqtree_file}' does not exist!")

        with open(iqtree_file, "r") as file:

            for line in file:

                if "Gamma shape alpha:" in line:
                    words = line.split()
                    alpha = float(words[3])

                    return alpha

        return alpha

    a_alpha = get_alpha(a_iqtree_file)
    b_alpha = get_alpha(b_iqtree_file)

    if not a_alpha:
        raise ValueError(f"Cannot extract weights, check if '{a_iqtree_file}' is formatted correctly!")

    if not b_alpha:
        raise ValueError(f"Cannot extract weights, check if '{a_iqtree_file}' is formatted correctly!")

    return a_alpha * a_weight + b_alpha * b_weight


def create_custom_nexus_file(weights, nexus_address, mixture_model, key_phrase):
    out_freqs = []

    # generate frequency section
    with open(nexus_address, "r") as nexus_file:
        section_found = False

        for line in nexus_file:

            # skip source comment or other
            if line.startswith(key_phrase):
                section_found = True
                continue

            # skip empty lines after begin models
            if section_found and line.startswith("frequency"):
                # for each line before encountering an empty line
                # prepend fundi to frequency names
                words = line.split()
                words[1] = f"fundi_{words[1]}"
                out_freqs.append(words)
                continue

            if section_found and line.startswith("model"):
                break

        # generate model section
        weight_statements = []
        new_mixture_model = f"fundi_{mixture_model}"

        for words, weight in zip(out_freqs, weights.values()):
            weight_statements.append(f"{words[1]}:1:{weight}")

        weight_line = f"model {new_mixture_model} = FMIX{{{','.join(weight_statements)}}};"

        # write to file
        with open("nex", "w") as nex_file:
            nex_file.write("#nexus\nbegin models;\n")

            for line in out_freqs:
                nex_file.write(" ".join(line) + "\n")

            nex_file.write(weight_line + "\n")

            nex_file.write("end;")

        return "nex", new_mixture_model


def run_iqtrees(trees, alignment_address, avg_alpha, model, nexus_file, all_cores, memory, leaves):

    def get_memory_requirement(log_file):

        if not os.path.isfile(log_file):
            raise FileNotFoundError(f"'{log_file}' does not exist!")

        with open(log_file, "r") as file:

            for line in file:

                if "NOTE: " in line:
                    return int(line.split(" ")[1])

    # generate iqtree commands
    iqtree_commands = {}

    for index, tree in enumerate(trees, start=1):
        formatted_index = f"{index:02d}"
        # render image of stitched-together-tree
        # tree.render(f"test_{i}.png") not supported on perun
        tree.write(format=1, outfile=f"test_{formatted_index}.tree")

        iqtree_command = [
            "iqtree2",
            "-s", alignment_address,
            "--tree-fix", f"test_{formatted_index}.tree",
            "-m", f"{model}{{{avg_alpha}}}",
            "--mdef", nexus_file,
            "-nt", "1",
            "--prefix", f"test_{formatted_index}",
            "-prec", "10",
            "-blfix",
            "--fundi", f"{','.join(leaves)},estimate",
            "-redo",
            "--quiet"
        ]

        iqtree_commands[formatted_index] = iqtree_command

    # get the memory requirement for a reconstructed tree, convert to gigabytes
    print(f"Running iqtree funDi for Tree 01 out of {len(trees)} and determining memory requirement.\n")
    subprocess.run(iqtree_commands.pop("01"), stderr=subprocess.DEVNULL)
    print("Completed running Tree 01 and memory determination.\n")
    mem_req = get_memory_requirement("test_01.log") * 0.001

    if all_cores < memory / mem_req:
        max_workers = all_cores
    else:
        max_workers = int(memory / mem_req)

    with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
        futures = []

        for index, iqtree_command in iqtree_commands.items():
            print(f"Running iqtree funDi for Tree {index} out of {len(trees)} in parallel.")
            futures.append(executor.submit(subprocess.run, iqtree_command, stderr=subprocess.DEVNULL))

        print()  # divider

        for future in concurrent.futures.as_completed(futures):
            result = future.result()
            print(f"Completed running Tree {result.args[4][5:7]}.")


def generate_summary(tree_count, model, increment, taxa_groups, keep):

    # get tree_properties
    tree_properties = []

    for index in range(1, tree_count + 1):
        formatted_index = f"{index:02d}"

        with open(f"test_{formatted_index}.log", "r") as iqtree_file:

            for line in iqtree_file:

                if "Best FunDi parameter rho:" in line:
                    words = line.split()
                    rho_value = float(words[4])
                    continue

                if "Best FunDi central branch length:" in line:
                    words = line.split()
                    central_branch_length = float(words[5])
                    continue

                if "FunDi log-likelihood:" in line:
                    words = line.split()
                    log_likelihood = float(words[2])
                    break

        # this is a problem with large datasets discovered and debugged on perun
        if not log_likelihood:
            raise NameError("Insufficient memory allocation!")

        tree_properties.append((formatted_index, log_likelihood, rho_value, central_branch_length))

    # sort the trees based on largest funDi log-likelihood
    sorted_tree_properties = sorted(tree_properties, key=lambda attr_tuple: attr_tuple[1], reverse=True)

    # we're overwriting the initial .png image,
    # but only for the best tree

    # style the tree
    # tree_style = TreeStyle()
    # tree_style.show_leaf_name = True
    # tree_style.show_branch_length = True
    # tree_style.branch_vertical_margin = 10
    #
    # # give each internal node an explicit name
    # for node in best_tree.traverse():
    #
    #     if not node.is_leaf():
    #         node.name = "node"

    # best_tree.render(file_name=f"test_{best_tree_index}.png", tree_style=tree_style, units="px", w=800, h=1000)
    best_tree = conform_iqtree_tree(f"test_{sorted_tree_properties[0][0]}.treefile", taxa_groups[0])
    best_tree.write(format=1, outfile=f"test_{sorted_tree_properties[0][0]}.treefile")

    # print to summary file
    print("\nGenerating summary...\n")

    with open("summary.txt", "w") as summary_file:

        summary_file.write(f"Trees generated: {tree_count}\n")
        summary_file.write(f"Model used: {model}\n")
        summary_file.write(f"Increment used: {increment}\n")

        best_index = sorted_tree_properties[0][0]

        summary_file.write(
            f"Best tree: Tree {best_index}\n"
            f"Best funDi log-likelihood: {sorted_tree_properties[0][1]}\n"
            f"rho: {sorted_tree_properties[0][2]}.\n"
            f"Central branch length: {sorted_tree_properties[0][3]}\n"
        )

        summary_file.write("\nRooted best tree:\n")

        # print tree with branch lengths
        summary_file.write(f"{best_tree.get_ascii(attributes=['name', 'dist'], show_internal=True)}\n\n")
        # summary_file.write(f"See \"test_{best_tree_index}.png\" for a tree illustration.\n\n")
        summary_file.write("The following list ranks the remaining trees based on best log-likelihood:\n")

        for index in range(1, len(sorted_tree_properties)):
            summary_file.write(f"funDi Log-likelihood of the tree {sorted_tree_properties[index][0]}: "
                               f"{sorted_tree_properties[index][1]}; "
                               f"rho: {sorted_tree_properties[index][2]}; "
                               f"central branch length: {sorted_tree_properties[index][3]}\n")

    print("Summary generated under \"summary.txt\".")

    subprocess.run(["mv", f"test_{best_index}.treefile", "best_tree.treefile"])
    subprocess.run(["mv", f"test_{best_index}.iqtree", "best_tree.iqtree"])
    subprocess.run(["mv", f"test_{best_index}.log", "best_tree.log"])
    subprocess.run(["mv", f"test_{best_index}.ckp.gz", "best_tree.ckp.gz"])

    if keep:
        return

    # Get a list of all filenames matching test_*.*
    # then constructs the command by appending these filenames to ["rm", "-f"].
    files = glob.glob("test_*.*")
    if files:
        subprocess.run(["rm", "-f"] + files)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Tree mapper")

    parser.add_argument("-te", "--tree", required=True, help="Tree file in newick format, must be rooted")

    parser.add_argument("-s", "--alignment", required=True, help="Alignment in fasta format")

    # TODO: improve description, give explicit examples
    parser.add_argument("-d", "--definition", required=True,
                        help="Definition file that splits the tree by FunDi branch")

    # TODO: list all available models
    parser.add_argument("-m", "--model", required=False, default="LG+C10+G",
                        help="Model to be used with iqtree. Syntax: Rate Matrix+Mixture Model+Rate Heterogeneity. "
                             "Default is LG+C10+G")

    # TODO: improve (the wording of?) this
    parser.add_argument("-i", "--increment", required=False, default="0.1",
                        help="Metric to control branch length variance, default is 0.1")

    parser.add_argument("-mdef", "--nexus", required=False, default=None,
                        help="Nexus file to be used with iqtree")

    parser.add_argument("-nt", "--cores", required=False, default="2",
                        help="Number of CPU cores to use")

    parser.add_argument("-mem", "--memory", required=False, default="8",
                        help="Amount of memory in gigabytes to use")

    parser.add_argument("-k", "--keep", required=False, action="store_true",
                        help="Keeps files associated with trees which are not the best")

    # emulating commandline arguments for development
    sys.argv = [
        "Mapper.py",
        "-te", "data/Hector/TAB",
        "-d", "data/Hector/def",
        "-s", "data/Hector/conAB1rho60.fa",
        "-i", "0.3",
        "-m", "LG+C10+G",
        "-k"
    ]

    arguments = parser.parse_args()

    start_time = time.time()
    main(arguments)
    end_time = time.time()
    print(f"\nRuntime: {end_time - start_time}")

